# @lc app=leetcode id=924 lang=python3
#
# [924] Minimize Malware Spread
#
# https://leetcode.com/problems/minimize-malware-spread/description/
#
# algorithms
# Hard (41.92%)
# Likes:    621
# Dislikes: 416
# Total Accepted:    37.3K
# Total Submissions: 89K
# Testcase Example:  '[[1,1,0],[1,1,0],[0,0,1]]\n[0,1]'
#
# You are given a network of n nodes represented as an n x n adjacency matrix
# graph, where the i^th node is directly connected to the j^th node if
# graph[i][j] == 1.
#
# Some nodes initial are initially infected by malware. Whenever two nodes are
# directly connected, and at least one of those two nodes is infected by
# malware, both nodes will be infected by malware. This spread of malware will
# continue until no more nodes can be infected in this manner.
#
# Suppose M(initial) is the final number of nodes infected with malware in the
# entire network after the spread of malware stops. We will remove exactly one
# node from initial.
#
# Return the node that, if removed, would minimize M(initial). If multiple
# nodes could be removed to minimize M(initial), return such a node with the
# smallest index.
#
# Note that if a node was removed from the initial list of infected nodes, it
# might still be infected later due to the malware spread.
#
#
# Example 1:
# Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
# Output: 0
# Example 2:
# Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
# Output: 0
# Example 3:
# Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
# Output: 1
#
#
# Constraints:
#
#
# n == graph.length
# n == graph[i].length
# 2 <= n <= 300
# graph[i][j] is 0 or 1.
# graph[i][j] == graph[j][i]
# graph[i][i] == 1
# 1 <= initial.length <= n
# 0 <= initial[i] <= n - 1
# All the integers in initial are unique.
#
#
#

# @lc tags=array

# @lc imports=start
from imports import *

# @lc imports=end

# @lc idea=start
#
# 有初始病毒位置，求去掉一个位置的病毒，最小化感染位置。
# 染色
#
# @lc idea=end

# @lc group=graph

# @lc rank=10


# @lc code=start
class Solution:

    def minMalwareSpread(self, graph: List[List[int]],
                         initial: List[int]) -> int:
        n = len(graph)
        adjs = [[] for _ in range(n)]
        for i, j in product(range(n), range(n)):
            if graph[i][j] == 1:
                adjs[i].append(j)

        noMalware = n
        multiMalware = n + 1

        graph = [noMalware for _ in range(n)]

        initial = set(initial)

        for i in initial:
            graph[i] = i

        for i in initial:
            if graph[i] != i:
                continue
            q = [(i, i)]
            while len(q) > 0:
                node, src = q.pop()
                for nextNode in adjs[node]:
                    g = graph[nextNode]
                    if g == multiMalware or g == src:
                        continue
                    if g == noMalware:
                        graph[nextNode] = src
                        q.append((nextNode, src))
                    else:
                        graph[nextNode] = multiMalware
                        q.append((nextNode, multiMalware))
        counter = Counter(graph)

        return min((-counter[i], i) for i in initial)[1]


# @lc code=end

# @lc main=start
if __name__ == '__main__':
    print('Example 1:')
    print('Input : ')
    print('graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]')
    print('Exception :')
    print('0')
    print('Output :')
    print(
        str(Solution().minMalwareSpread([[1, 1, 0], [1, 1, 0], [0, 0, 1]],
                                        [0, 1])))
    print()

    print('Example 2:')
    print('Input : ')
    print('graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]')
    print('Exception :')
    print('0')
    print('Output :')
    print(
        str(Solution().minMalwareSpread([[1, 0, 0], [0, 1, 0], [0, 0, 1]],
                                        [0, 2])))
    print()

    print('Example 3:')
    print('Input : ')
    print('graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]')
    print('Exception :')
    print('1')
    print('Output :')
    print(
        str(Solution().minMalwareSpread([[1, 1, 1], [1, 1, 1], [1, 1, 1]],
                                        [1, 2])))
    print()

    pass
# @lc main=end